//!(kind of) Safe and (kind of) rust-y bindings over (ngn/)k
//!
//!Use is almost identical to C except types
//!
//![Usage example](https://codeberg.org/ngn/k/src/branch/master/x/embed/a.c)
#![allow(non_upper_case_globals)]#![allow(non_camel_case_types)]#![allow(non_snake_case)]
pub mod raw {//!Raw, unsafe bindings to C generated by bindgen
    include!(concat!(env!("OUT_DIR"),"/B.rs"));}
use std::mem::{size_of,transmute};use std::ffi::CString;
macro_rules! mV {($a:expr,$b:expr)=>{$a.iter().map(|x| $b(x)).collect::<Vec<String>>()}}
macro_rules! cV {($a:expr)=>{$a.clone().as_mut_ptr()}}
macro_rules! Vc {($a:ty,$va:ident,$vb:ident)
    =>{Vec::from_raw_parts($vb,NK($va)/size_of:: <$a>(),0)} }
macro_rules! Kmf {($name:ident,$ta:ty,$tb:ty,$a:ident,$($arg:expr),*)=>{pub fn $name($a:$ta)->$tb{unsafe{raw::$name($($arg),*)}}}}
macro_rules! KVt {($name:ident,$t:ty)
    =>{pub fn $name(a:K)->Vec<$t>{let L=NK(a);let mut O:Vec<$t>=Vec::with_capacity(L);
                                  unsafe { raw::$name(O.as_mut_ptr(),a);O.set_len(L); } O}}}
macro_rules! Cs {($a:expr)=>{$a.as_ptr()as*const i8}}
macro_rules! Ns {($a:expr)=>{(&CString::new($a).expect("CStr")).as_ptr()}}
pub type K=raw::K;pub type V=raw::V;
fn NS(a:&String)->String{format!("{}\0",a)}
fn i8C(a:i8)->char{a as u8 as char}
Kmf![Kc, char,K, a,a as i8]; Kmf![Ks, &'static str,K, a,String::from(a).as_mut_ptr()as*mut i8];
Kmf![Ki, i32,K, a,a]; Kmf![Kf, f64,K, a,a];
Kmf![KC, Vec<char>,K, a,cV![a]as*mut i8,a.len()]; Kmf![KS, Vec<String>,K, a,mV![a.clone(),NS].as_mut_ptr()as *mut*mut i8,a.len()];
Kmf![KI, Vec<i32>,K, a,cV![a],a.len()]; Kmf![KF, Vec<f64>,K, a,cV![a],a.len()];
Kmf![KL, Vec<K>,K, a,cV![a],a.len()];
pub fn TK(a:K)->char{unsafe{i8C(raw::TK(a))}} Kmf![NK, K,usize, a,a];
pub fn cK(a:K)->char{unsafe{i8C(raw::cK(a))}}
Kmf![iK, K,i32, a,a]; Kmf![fK, K,f64, a,a];
pub fn CK(a:K)-> String {
    let L = NK(a);
    let mut O:Vec<i8> = Vec::with_capacity(L);
    unsafe {
        raw::CK(O.as_mut_ptr(), a);
        O.set_len(L);
        String::from_utf8(transmute(O)).unwrap()
    }
}
KVt![IK,i32]; KVt![FK,f64]; pub fn LK(a:K) -> Vec<i64>{
    let L = NK(a);
    let mut O:Vec<i64> = Vec::with_capacity(L);
    unsafe {
        raw::LK(O.as_mut_ptr(),a);
        O.set_len(L);
    }O
}
Kmf![dK, K,*mut V, a,a];
///Execute K code in s with arguments f
pub fn K0(s:String,f:Vec<K>)->K{
    unsafe{ let mut v:i64=0;raw::K0(&mut v,Ns![s],cV![f],f.len()as i32) }}
///Assign variables s to values v
pub fn KA(s:String,v:K){unsafe{raw::KA(Cs![s.as_str()],v)}}//i think this is the main incompat point between ngn/k and other ks(types)
///Register extension s doing f of arity a
///
///f needs to be a pointer: it's just writing `f as*mut V`
pub fn KR(s:String,f:*mut V,a:i32){unsafe{raw::KR(Ns![s],f,a)}}
///Increment ref count
pub fn Kref(x:K)->K{unsafe{raw::ref_(x)}}
///Decrement ref count
pub fn Kunref(x:K){unsafe{raw::unref(x)}}
Kmf![KE, &'static str,K, s,Ns![s]];
pub fn kinit(){unsafe{raw::kinit()}}
#[cfg(test)]mod t{
    use super::*;
    fn kadd(x:K,y:K)->K{let a=iK(x);let b=iK(y);let c=a+b;Ki(c)}
    #[test]fn extensions(){kinit();KR(String::from("add"),kadd as *mut V,2);
        assert_eq!(IK(K0(String::from("1,add[2;3]"),vec![])),vec![1,5]);
        assert_eq!(IK(K0(String::from("1,add[1;2]"),vec![])),vec![1,3]);
        assert_eq!(LK(K0("{x+,/a,''+a:&'y y#1}".to_string(),vec![Ki(400),Ki(10)])),vec![]);}}
